// Generated by CoffeeScript 1.6.3
(function() {
  var CameraControll, God, Particle, ParticleManager, Ray, Target, __DEBUG__;

  __DEBUG__ = false;

  God = (function() {
    function God() {}

    God.setup = function() {
      var c, i;
      this.deviceWidth = 640.0;
      this.deviceHeight = 480.0;
      this.scene = new THREE.Scene();
      this.scene.fog = new THREE.FogExp2(0x000000, 0.03);
      this.camera = new THREE.PerspectiveCamera(90, this.deviceWidth / this.deviceHeight, Math.pow(0.1, 8), Math.pow(10, 3));
      this.renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this.renderer.setSize(this.deviceWidth, this.deviceHeight);
      c = document.getElementById('c');
      c.appendChild(this.renderer.domElement);
      this.rays = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i <= 7; i = ++_i) {
          _results.push(new Ray(this.scene, i));
        }
        return _results;
      }).call(this);
      this.target = new Target(this.scene, {
        x: 0,
        y: 0,
        z: 0
      });
      this.cameraControll = new CameraControll(this.camera);
      return this.particleManager = new ParticleManager();
    };

    God.start = function() {
      var render,
        _this = this;
      render = function() {
        var ray, _i, _len, _ref;
        _this.camera.position.z = 5;
        _this.target.update();
        _this.cameraControll.update();
        _ref = _this.rays;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          ray = _ref[_i];
          ray.update();
        }
        _this.particleManager.update();
        requestAnimationFrame(render);
        return _this.renderer.render(_this.scene, _this.camera);
      };
      return render();
    };

    return God;

  })();

  CameraControll = (function() {
    function CameraControll(camera) {
      this.camera = camera;
      this.lookAt = new THREE.Vector3(0, 0, 0);
      this.count = 0;
    }

    CameraControll.prototype.update = function() {
      var pTarget;
      pTarget = God.rays[0].position();
      this.pTarget = new THREE.Vector3(Math.sin(this.count * 0.022) * 15, Math.cos(this.count * 0.034) * 15, Math.sin(this.count * 0.026) * 15);
      this.lTarget = new THREE.Vector3(Math.sin(this.count * 0.021) * 5, Math.cos(this.count * 0.031) * 5, Math.sin(this.count * 0.016) * 5);
      this.camera.position.x = (this.camera.position.x * 8 + this.pTarget.x * 3) / 10;
      this.camera.position.y = (this.camera.position.y * 8 + this.pTarget.y * 3) / 10;
      this.camera.position.z = (this.camera.position.z * 8 + this.pTarget.z * 3) / 10;
      this.lookAt.x = (this.lookAt.x * 8 + this.lTarget.x * 2) / 10;
      this.lookAt.y = (this.lookAt.y * 8 + this.lTarget.y * 2) / 10;
      this.lookAt.z = (this.lookAt.z * 8 + this.lTarget.z * 2) / 10;
      this.camera.lookAt(this.lookAt);
      return this.count++;
    };

    CameraControll.prototype.perspectiveVector = function() {
      var s;
      s = God.target.position.clone();
      return s.sub(this.camera.position).normalize();
    };

    return CameraControll;

  })();

  Target = (function() {
    Target.material = new THREE.MeshBasicMaterial({
      color: 0x111155,
      transparent: true,
      depthTest: false,
      blending: THREE.AdditiveBlending,
      side: THREE.DoubleSide
    });

    function Target(scene, p) {
      this.scene = scene;
      this.count = 0;
      this.speed = new THREE.Vector3(0.0, 0.0, 0.0);
      this.geometry = new THREE.BoxGeometry(1.0, 1.0, 1.0);
      this.mesh = new THREE.Mesh(this.geometry, Target.material);
      this.position = this.mesh.position;
      this.goalPos = this.position.clone();
      if (__DEBUG__) {
        this.scene.add(this.mesh);
      }
    }

    Target.prototype.update = function() {
      var diff, len;
      diff = this.goalPos.clone();
      diff.sub(this.position);
      len = diff.length();
      if (this.count % 1000 === 0 || len < 1) {
        this.goalPos.x = 20.0 * Math.random() - 10;
        this.goalPos.y = 20.0 * Math.random() - 10;
        this.goalPos.z = 20.0 * Math.random() - 10;
      }
      diff.normalize();
      diff.multiplyScalar(0.1);
      this.speed.add(diff);
      this.speed.multiplyScalar(0.95);
      this.position.add(this.speed);
      return this.count++;
    };

    return Target;

  })();

  Ray = (function() {
    var Bone;

    Bone = (function() {
      function Bone(index, p) {
        this.index = index;
        this.position = new THREE.Vector3(p.x, p.y, p.z);
        this.direction = new THREE.Vector3();
      }

      return Bone;

    })();

    function Ray(scene, nth) {
      var color, i, index, m, p, v, vi, _i, _j, _len, _ref, _ref1;
      this.scene = scene;
      this.nth = nth;
      this.speed = new THREE.Vector3(0, 0.1, 0);
      m = 24;
      p = {
        x: Math.random(),
        y: Math.random(),
        z: Math.random()
      };
      this.bones = (function() {
        var _i, _results;
        _results = [];
        for (index = _i = 0; 0 <= m ? _i < m : _i > m; index = 0 <= m ? ++_i : --_i) {
          _results.push(new Bone(index, p));
        }
        return _results;
      })();
      this.geometry = new THREE.Geometry();
      _ref = this.bones;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        v = _ref[i];
        this.geometry.vertices.push(new THREE.Vector3(-1, i, 0), new THREE.Vector3(1, i, 0));
      }
      for (i = _j = 0, _ref1 = m - 1; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        vi = i * 2;
        this.geometry.faces.push(new THREE.Face3(vi, vi + 1, vi + 2), new THREE.Face3(vi + 1, vi + 3, vi + 2));
        this.geometry.faceVertexUvs[0].push([new THREE.Vector2(1.0, 0.0), new THREE.Vector2(0.0, 0.0), new THREE.Vector2(1.0, 1.0)], [new THREE.Vector2(0.0, 0.0), new THREE.Vector2(0.0, 1.0), new THREE.Vector2(1.0, 1.0)]);
      }
      color = new THREE.Color();
      color.setHSL(this.hue(), 1.0, 0.7);
      this.material = new THREE.MeshBasicMaterial({
        color: color,
        map: this.makeTexture(),
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending,
        transparent: true
      });
      this.mesh = new THREE.Mesh(this.geometry, this.material);
      this.scene.add(this.mesh);
    }

    Ray.prototype.hue = function() {
      return 1.0 * this.nth / 7;
    };

    Ray.prototype.makeTexture = function() {
      var ctx, grad, height, width;
      if (!this.texture) {
        this.canvas = document.createElement('canvas');
        width = this.canvas.width = 32;
        height = this.canvas.height = 32;
        ctx = this.canvas.getContext('2d');
        grad = ctx.createLinearGradient(0, 0, width, 0);
        grad.addColorStop(0, 'rgb(0, 0, 0)');
        grad.addColorStop(0.5, 'rgb(255, 255, 255)');
        grad.addColorStop(1, 'rgb(0, 0, 0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.rect(0, 0, width, height);
        ctx.fill();
        this.texture = THREE.ImageUtils.loadTexture(this.canvas.toDataURL());
        if (__DEBUG__) {
          document.body.appendChild(this.canvas);
        }
      }
      return this.texture;
    };

    Ray.prototype.position = function() {
      return this.bones[0].position;
    };

    Ray.prototype.update = function() {
      var bone, d, diff, direction, i, n, p, pv, s, speed, target, w, _i, _j, _k, _len, _ref, _ref1, _ref2;
      target = God.target;
      diff = target.position.clone();
      diff.sub(this.position());
      diff.multiplyScalar(0.35 - 0.04 * this.nth);
      this.speed.add(diff);
      this.speed.multiplyScalar(0.99 - 0.005 * this.nth);
      for (n = _i = _ref = this.bones.length - 1; _ref <= 1 ? _i <= 1 : _i >= 1; n = _ref <= 1 ? ++_i : --_i) {
        this.bones[n].position.copy(this.bones[n - 1].position);
        this.bones[n].direction.copy(this.bones[n - 1].direction);
      }
      this.bones[0].position.add(this.speed);
      direction = this.speed.clone();
      direction.normalize();
      this.bones[0].direction = direction;
      pv = God.cameraControll.perspectiveVector();
      _ref1 = this.bones;
      for (i = _j = 0, _len = _ref1.length; _j < _len; i = ++_j) {
        bone = _ref1[i];
        i = bone.index;
        p = bone.position;
        d = bone.direction;
        s = new THREE.Vector3();
        s.crossVectors(pv, d);
        w = Math.sin(1.0 * i / this.bones.length * Math.PI * 2) * 0.1;
        s.multiplyScalar(w);
        this.geometry.vertices[i * 2 + 0].set(p.x + s.x, p.y + s.y, p.z + s.z);
        this.geometry.vertices[i * 2 + 1].set(p.x - s.x, p.y - s.y, p.z - s.z);
      }
      for (i = _k = 0, _ref2 = this.bones.length - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
        if (Math.random() * i > 12.0 && Math.random() < 0.8) {
          bone = this.bones[i];
          speed = new THREE.Vector3(Math.random() * 0.2 - 0.4, Math.random() * 0.2 - 0.4, Math.random() * 0.2 - 0.4);
          speed.add(this.speed.clone().multiplyScalar(-0.25));
          God.particleManager.add(this.scene, this.hue(), bone.position, speed);
        }
      }
      return this.geometry.verticesNeedUpdate = true;
    };

    return Ray;

  })();

  ParticleManager = (function() {
    function ParticleManager() {
      this.particles = [];
    }

    ParticleManager.prototype.update = function() {
      var particle, _i, _len, _ref, _results;
      _ref = this.particles;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        particle = _ref[_i];
        if (particle.alloced()) {
          particle.update();
          if (particle.speed.lengthSq() < 0.1 || particle.count > 50) {
            _results.push(this.free(particle));
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    ParticleManager.prototype.add = function(scene, hue, position, speed) {
      var particle, _i, _len, _ref;
      this.scene = scene;
      _ref = this.particles;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        particle = _ref[_i];
        if (!particle.alloced() && particle.hue === hue) {
          particle.alloc(position, speed);
          return particle;
        }
      }
      return this.particles.push(new Particle(this.scene, hue, position, speed));
    };

    ParticleManager.prototype.free = function(particle) {
      var otherParticle, _i, _len, _ref, _results;
      _ref = this.particles;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        otherParticle = _ref[_i];
        if (particle.eq(otherParticle)) {
          _results.push(particle.free());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return ParticleManager;

  })();

  Particle = (function() {
    Particle.materialMemo = {};

    Particle._id = 0;

    function Particle(scene, hue, position, speed) {
      this.scene = scene;
      this.hue = hue;
      this.material = this.retrieveMaterial(hue);
      this.mesh = new THREE.Sprite(this.material);
      this.id = Particle._id++;
      this.alloc(position, speed);
      this.scene.add(this.mesh);
    }

    Particle.prototype.eq = function(that) {
      return this.id === that.id;
    };

    Particle.prototype.alloc = function(position, speed) {
      this.count = 0;
      this.position = position.clone();
      this.speed = speed.clone();
      return this.mesh.visible = true;
    };

    Particle.prototype.free = function() {
      return this.mesh.visible = false;
    };

    Particle.prototype.alloced = function() {
      return this.mesh.visible;
    };

    Particle.prototype.position = function() {
      return this.mesh.position;
    };

    Particle.prototype.update = function() {
      var size;
      this.speed.multiplyScalar(0.98);
      this.position.add(this.speed);
      this.mesh.position.copy(this.position);
      size = this.speed.length();
      this.mesh.scale.set(size, size, size);
      return this.count++;
    };

    Particle.prototype.retrieveMaterial = function(hue) {
      var color, key;
      key = "" + hue;
      if (!Particle.materialMemo[key]) {
        color = new THREE.Color();
        color.setHSL(hue, 0.5, 0.5);
        this.material = new THREE.SpriteMaterial({
          map: this.makeTexture(),
          color: color,
          transparent: true,
          blending: THREE.AdditiveBlending
        });
        Particle.materialMemo[key] = this.material;
      }
      return Particle.materialMemo[key];
    };

    Particle.prototype.makeTexture = function() {
      var ctx, grad, height, width;
      if (!this.texture) {
        this.canvas = document.createElement('canvas');
        width = this.canvas.width = 64;
        height = this.canvas.height = 64;
        ctx = this.canvas.getContext('2d');
        grad = ctx.createRadialGradient(0.5 * width, 0.5 * height, 0.05 * width, 0.5 * width, height * 0.5, 0.5 * width);
        grad.addColorStop(0, 'rgb(255, 255, 255)');
        grad.addColorStop(0.4, 'rgb(255, 255, 255)');
        grad.addColorStop(1, 'rgb(0, 0, 0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.rect(0, 0, width, height);
        ctx.fill();
        this.texture = THREE.ImageUtils.loadTexture(this.canvas.toDataURL());
        if (__DEBUG__) {
          document.body.appendChild(this.canvas);
        }
      }
      return this.texture;
    };

    return Particle;

  })();

  window.God = God;

}).call(this);

/*
//@ sourceMappingURL=7rays.map
*/
